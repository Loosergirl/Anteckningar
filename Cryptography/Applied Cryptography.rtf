{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1053{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset2 Symbol;}}
{\*\generator Riched20 10.0.15063}\viewkind4\uc1 
\pard\sl240\slmult1\b\f0\fs32\lang29 Protocol Building Blocks\par
\fs22 Protocol\b0 : "A series of steps, involving two or more parties, designed to accomplish as task." There is a sequence from start to finish. A \b cryptographic protocol \b0 uses cryptography. It should not be possible to do more or learn more than what is specified in the protocol.\par
\par
Intelligent muffin toasters...\par
\par
\b Arbitrator\b0 : Disinterested third party used to complete a protocol. Has no vested interest in the protocol.\par
\par
Alice, Bob, Carol, Dave -> Protocol participants\par
Eve - Eavesdropper\par
Mallory - Malicious active attacker\par
Trent - Trusted arbitrator\par
Walter - Warden\par
Peggy - Prover\par
Victor - Verifier\par
\par
Arbitrated protocol, Adjudicated protocol (when there has been a dispute, the parties present evidence to an adjudicator), Self-enforcing protocol (perfect scenario where cheating is detected immediately). \par
\par
\b Internet disadvantages of an arbitrator\b0 :\par

\pard{\pntext\f1\'B7\tab}{\*\pn\pnlvlblt\pnf1\pnindent0{\pntxtb\'B7}}\fi-360\li720\sl240\slmult1 No face leads to less trust.\par
{\pntext\f1\'B7\tab}Cost of maintaining an arbitrator.\par
{\pntext\f1\'B7\tab}Delay in the arbitrated protocol.\par
{\pntext\f1\'B7\tab}Acts as a bottleneck in large-scale implementations.\par
{\pntext\f1\'B7\tab}A vulnerable point for anyone trying to subvert the network.\par

\pard\sl240\slmult1\par
\b Subprotocols\b0\par
Arbitrated protocols may be divided into two types. One which is non-arbitrated, and another which is; the latter is only executed when there is a dispute.\par
\par
\b Passive attack\b0 : Someone eavesdrop on some or all of the protocol. Difficult to detect; therefore prevention is used.\par
\b Active attack\b0 : An attacker alters the protocol. \par
\par
\b Cheater\b0 : An attacker who lies during protocol and doesn't follow it.\par
\b Passive cheater\b0 : Follows the protocol, but tries to obtain more information than intended.\par
\b Active cheater\b0 : Disrupts the protocol.\par
\par
"A good cryptosystem is one in which all the security is inherent in knowledge of the key and none is inherent in knowledge of the algorithm."\par
\par
\b Problems with symmetric cryptosystems\b0 :\par
Keys must be distributed in secret. A daunting task for encryption systems spanning the world.\par
Keys may be compromised.\par
The total number of keys increases rapidly as the number of users increases. With \i n\i0  users \i n\i0 (\i n\i0  -1)/2 keys are necessary.\par
\par
\b One-way function\b0 : Easy to compute, but hard to reverse. \i x\i0  easily gives \i f\i0 (\i x\i0 ), but it's hard to find \i x\i0  with only \i f\i0 (x).\par
\b Tropdoor one-way function\b0 : When a function has a secret trapdoor. It is easy to compute \i f\i0 (\i x\i0 ) given \i x\i0 , but hard to compute \i x\i0  given \i f\i0 (\i x\i0 ). Some secret information, \i y\i0 , allows easy computation of \i f\i0 (\i x\i0 ).\par
\par
\b Hash function\b0 : Takes a variable-length string and converts it into a fixed-length string called a hash value.\par
\b One-way hash function\b0 : The hash function works in one direction. It is easy to compute a hash value but hard to generate the pre-image. Its security is its one-wayness.\par
\b Collision free\b0 : When it is hard to generate two pre-images with the same hash value. Good one-way hash functions are this.\par
\par
\b Message authentification code (MAC)\b0 : Also known as data authentification code (DAC). A one-way hash function coupled with a key. Only someone with the key can verify the hash value.\par
\par
\b Public-key cryptography\b0 : One public key, one private key. It would be hard to deduce the private key from the public key. Thus the public key allows encryption but not decryption. Only the private key allows decryption. Based on the trapdoor one-way functions. Eavesdroppers only see the key to encrypt, not decrypt.\par
\par
Two downsides of public-key algorithms are (1) low speed, and (2) vulnerability to chosen-plaintext attacks. Public-key algorithms are used to encrypt keys, while symmetric algorithms are used for messages.\par
\par
\b Session keys\b0 : Most practical implementation of public-key cryptography. They are used with symmetric algorithms to secure message traffic. This is sometimes called \b hybrid cryptosystem\b0 .\par
\par
\b Digitial signature\b0 : There are public key algorithms that can be used for digital signatures. Sometimes, as in RSA, either the public or private key can be used for encryption. Otherwise, as with DSA, a separate algorithm is used for digital signatures that cannot be used for encryption. Timestamps are included so the digital signatures cannot be resused. \par
\par
One-way hash functions may be signed instead of a document to save time.\par
\par
Signing is sometimes called \b encrypting with a private key\b0 , while verification is sometimes called \b decrypting with a public key\b0 . This is only true for RSA. In the book, referred to as \i S\sub K\nosupersub\i0 (\i M\i0 ) and \i V\sub K\nosupersub\i0 (\i M\i0 ) respectively.\par
\par
For more people to sign the same document, they would either sign one copy each or they would sign each others signatures.\par
\par
\b Key certification authority or key distribution center (KDC)\b0 : When a trusted third party signs each public key stored in his database using his own private key.\par
\par
\b Random number generation\par
\b0 Standard random number generators are not random enough to be used in cryptography.\par
\par
\b Pseudo-random-sequence generator\b0 : The best a computer can produce concerning random. A sequence period should be long enough so that a finite sequence of reasonable length is not periodic. Short, periodic, sequences should be as indistinquishable as possible from random sequences. However, every pseudo-random-sequence generator will produce weird correlations and strange results if used in a certain way. This can be used by a cryptanalyst to attack the system.\par
\par
\b Cryptographically secure pseudo-random\b0 : It must be unpredictable to have this property. It must be computationally infeasible to predict. Sequences should not be compressible unless you know the key.\par
\par
\b Real random\b0 : It is said to be this if it cannot be reliably reproduced.\par
\par
\b\fs32 Basic Protocols\b0\par
\b\fs22 Man-in-the-middle  attack\b0 : When a hacker intercepts communication between two parties and substitutes the public keys with his own.\par
\par
\b Interlock protocol\b0 : Used to foil the man-in-the-middle attack. Messages are broken into parts and sent separately. Part of the message is useless and cannot be decrypted. \par
\par
Digital signatures from the KDC may also be used to prevent the man-in-the-middle attack.\par
\par
\b\fs32 Key Length\b0\fs22\par
\b Brute-force attack\b0 : Trying every possible key. A form of known-plaintext attack. For a block cipher, Only possible with a block of ciphertext and the corresponding plaintext.\par
\par
The longer the key length, the longer it would take to find it using a brute-force attack. \par
\par
The two parameters determining the speed of a brute-force attack are the number of keys to be tested and the speed of each test. Parallell processors speed it up.\par
\par
Breaking 56-bit keys are within the budgets of most large companies and criminal organizations. Military budgets of industrialized nations can afford to break 64-bit keys. 80-bit keys are currently impossible to break, but this will change in 30 years. It may be wise to insist on a 112-bit key to account for unexpected breakthroughs.\par
\par
\b Mips-years\b0 : Computing power is measured in mips-years. A one million-instruction-per-second (mis) computer running for one year, or 3*10\super 13\nosupersub  instructions.\par
\par
\b General number field sieve\b0 : Used to factor large numbers. The \b special number field sieve \b0 is used to factor numbers not generally used for cryptography; this is faster.\par
\par
\b\fs32 Key Management\b0\fs22\par
It is important that the issuer of keys is a trusted party, not a scammer. Otherwise, no hacking is necessary for the key manager to read all messages. Keeping keys secret is also an issue. Bribes make the people responsible sell keys to outsiders.\par
\par
Commercial products may simply use DES and nothing else, making such mistakes as storing the key together with the encrypted material.\par
\par
The key generation process must have a cryptographycally strong process.\par
\par
Users will choose weak passwords. A \b dictionary attack \b0 tries the obvious keys first, continuing with the gradually less obvious ones. Tricks to improve password security may be taken into consideration, such as replacing letters with numbers. This type of attack is more powerful when used against a file of keys. Good keys are random-bit strings.\par
\par
\b Pass phrases\b0 : Using an entire phrase instead of a word as a password then convert that phrase into random keys with a one-way hash function.\par
\par
\b Nonlinear keyspace\b0 : When not all keys are equally strong. The opposite is linear/flat keyspace. The easiest way to create this is to create the key as two parts; if it gets a fixed string it uses the key normally, while it uses a weaker algorithm if not.\par
\par
\b Key-Encryption Keys\b0 : Used to encrypt other keys for distribution. Has to be distributed manually. Cumbersome in large networks as the total number of keys has to be \i n\i0 (\i n\i0 -1)/2.\par
\b Data Keys\b0 : Used to encrypt message traffic.\par
\par
An other alternative is to split the key into different parts and send them over different channels.\par
\par
If someone controlled all the network around a user, that person could easily be deceived by a different public key from that someone. However, it is still difficult to substitute one key for another. Various forms of verification can be used, such as a voice over telephone, or a one-way hash function.\par
\par
Because keys may be garbled in transition, error detection and correction is necessary.\par
\par
\b Verification block\b0 : A naive method to verify if a key is the correct symmetric decryption key. It is a known header to the plaintext message before encryption. An eavesdropper would then receive a known plaintext to help cryptanalyze the system. It is better to precalculate the checksum for each key.\par
\par
During encryption, the operating system may suspend the process and write everything to disk, including the unencrypted key. It is impossible to tell when the key would be overwritten, if ever. Encryption may be set to high priority to avoid interruption. Special hardware can be used to bypass the remaining risk. Sometimes session keys are used for this.\par
\par
To control how session keys are used, a \b Control Vector\b0  may be attached to specify the uses and restrictions of a key. The CV is then hashed and XORed with a master key, with the result being used as an encryption key for the session key. The session key is recovered by hashing the CV and XORing it with the master key.\par
\par
\b Key updating\b0 : Since it is a pain to change a key daily, a new key is generated from the old key instead. \par
\par
If a user wants to encrypt files and access them at a later date, the key must be stored somehow. A new key may be generated from a user input using a key-crunching technique. Or, the key may be stored in a magnetic stripe card, a ROM chip (\b ROM key\b0 ), or smart card. The key is then useable without the user being able to compromise it.\par
\par
\b Key escrow\b0 : To prevent employee keys from disappearing when said employees leave, the company collect the keys and either physically lock them up or encrypt them with a master key.\par
\par
A secret-sharing protocol is better to avoid the employee keys from being misused by the security officer. New keys are then split into pieces, encrypted, and sent to different company officers. Alternatively, the employee may encrypt the new key with the company public keys and store them on her harddrive.\par
\par
A compromised key of a symmetric cryptosystem must be changed. If it is a private key, it is vital the news of the compromise propagates quickly through the network. Databases with public keys must be immediately notified, lest some suspicious person encrypts a message in the compromised key. A timestamp can be used to see which messages are suspect. Biometrics, limits on what can be done with a key, time delays, and countersigning may reduce the problem.\par
\par
The longer a key is used, the greater the chance that it will be compromised. Longer use also means a greater loss if it is compromised, as the key will have been used for more things. It is also easier to cryptoanalyze with more material.\par
\par
\b Public key certificate\b0 : Someone's public key, signed by a trustworthy person (a CA). Used o thwart attempts to substitute one key for another.\par
\par
\b Introducers\b0 : Other users of a system who sign their friends' public keys. Must be sure a key belongs to the correct person to prevent substitution of keys by outsiders.\par
\par
\b\fs32 Mathematical Background\b0\fs22\par
\b Entropy and Uncertainty\par
\b0 Information theory defines the amount of information in a message as the minimum number of bits needed to encode all possible meanings of that message, assuming all messages are equally likely. For example, the week uses 3 bits:\par
000 = Sunday; 001 = Monday; 010 = Tuesday; 011 = Wednesday; 100 = Thursday; 101 = Friday; 110 = Saturday; 111 is unused.\par
\par
1 bit - 2 options\par
2 bit - 4 options\par
3 bit - 8 options\par
\par
The amount of information in a message \i M\i0  is measured by the entropy of the message, \i H\i0 (\i M\i0 ). For gender, it is 1 bit, and for the week it is slightly less than 3. Usually, the entropy of a message  measured in bits is log\sub 2\nosupersub  \i n\i0 , with \i n\i0  being the number of possible meanings. This assumes each meaning is equally likely. \par
\par
The entropy of a message also measures its uncertainty. If the ciphertext block "QHP*5M" is either "male" or "female", the uncertainty of the message will be 1. Only one bit needs to be learned to recover the message.\par
\par
\b Rate of a language\b0\par
For a given language, the rate of the language is\par
\i r\i0  = \i H\i0 (\i M\i0 )/\i N\i0\par
where \i N\i0  is the length of the message.\par
\par
The \b absolute rate\b0  of a language is the maximum number of bits that can be coded in each character, given each character sequence is equally likely. If there are \i L\i0  characters in a language, the absolute rate is:\par
\i R\i0  = log\sub 2\nosupersub  \i L\i0\par
\par
The \b redundancy\b0  of a language, denoted \i D\i0 , is defined as\par
\i D\i0  = \i R\i0  - \i r\i0\par
\par
\b Security of a cryptosystem\b0\par
The goal of a cryptoanalyst is to determine the key \i K\i0 , the plaintext \i P\i0 , or both. However, he may be satisfied with some probabilistic information about \i P\i0 . Usually, the cryptoanalyst has some probabilistic information about \i P\i0  even before analysis, because the language used is probably known, with its associated redundancy. One can guess if a message begins with a greeting.\par
\par
\b Perfect secrecy \b0 may be obtained if the number of possible keys is at least as large as the number of possible messages. Thus the key must be at least as long as the message itself, and no key can be reused.\par
\par
The entropy of a cryptosystem is a measure of the size of the keyspace, K. Approximated as:\par
\i H\i0 (\i K\i0 ) = log\sub 2\nosupersub  \i K\i0\par
\par
The greater the entropy, the harder it is to break the system.\par
\par
\b Unicity distance\b0\par
For a message of length \i n\i0 , the number of different keys that will decifer a cipher-text message to some intelligible plaintext in the same language as the original plaintext is given the formula:\par
2\super\i H\i0 (\i K\i0 ) - \i nD\nosupersub\i0  - 1\par
\par
The unicity distance, \i U\i0 , is an approximation of the amount of ciphertext such that the sum of the real information (entropy) in the corresponding plaintext plus the entropy of the encryption key equals the number of ciphertext bits used. iphertexts longer than this distance are reasonably certain to only  have on meaningful decryption. With shorter ciphertexts there is likely to be multiple, equally valid, decryptions. Therefore, there is security in this since an opponent won't be able to choose the correct one.\par
\par
For most symmetric cryptosystems, the unicity distance becomes\par
\i U\i0  = \i H\i0 (\i K\i0 )/\i D\i0\par
\par
The unicity distance is inversely proportional to the redundancy.\par
\par
A cryptosystem with infinite unicity distance has ideal secrecy. This isn't necessarily a perfect cryptosystem.\par
\par
Most literature on applying information theory to cryptoanalysis remains classified.\par
\par
\b Confusion and diffusion\b0\par
Confusion obscures the relationship between the plaintext and the ciphertext. Substitution is the simplest way, such as the Caesar Cipher where every letter is replaced with another.\par
\par
Diffusion dissipates the redundancy of the plaintext by spreading it out over the ciphertext. The simplest way to do this is transposition/permutation, where the letters are rearranged.\par
\par
\b Complexity theory\b0\par
The methodology for analyzing \b computational complexity\b0  of cryptographic techniques and algorithms. Algorithms and techniques are compared and their securty is determined.\par
\par
\b Complexity of algorithms\b0\par
Determined by the computational power needed for execution. \i T\i0  for \b time complexity \b0 and \i S\i0  for \b space complexity \b0 (memory requirement); both are expressed as functions of \i n\i0 , where \i n\i0  is the size of the input. Computational complexity is expressed by the order of magnitude of the computational complexity (\i O\i0 ). Grows as \i n\i0  grows larger.\par
\par
An algorithm is \b constant\b0  if its complexity is independent of \i n\i0 , i.e. \i O\i0 (1). It is \b linear\b0  if its time complexity is \i O\i0 (\i n\i0 ). Algorithms may be quadratic, cubic, etc. They are then \b polynomial\b0 ; their complexity is \i O\i0 (\i n\super m\nosupersub\i0 ) where \i m\i0  is a constant. Algorithms with a polynomial time complexity are called \b polynomial-time\b0  algorithms.\par
\par
Algorithms whose complexities are \i O\i0 (\i t\super f\i0 (\i n\i0 )\nosupersub ), where \i t\i0  is a constant greater than 1 and \i f\i0 (\i n\i0 ) is a polynomial function of \i n\i0 , are called \b exponential\b0 . The subset of exponential algorithms with \i O\i0 (\i c\super f\i0 (\i n\i0 )\nosupersub ) complexity, where \i c\i0  is a constant and \i f\i0 (\i n\i0 ) is more than constant but less than linear, are called \b superpolynomial\b0 . The strongest statements that can be made are of the form "all known cracking algorithms for this cryptosystem are of superpolynomial-time complexity".\par
\par
As \i n\i0  grows, the time complexity of an algorithm can make an enormous difference in whether the algorithm is practical. \par
\par
\b Complexity of problems\b0\par
Problems may also be classified by complexity theory. How much time and space would be required to solve the hardest instance of a problem on a \b Turing machine \b0 (a theoretical computer).\par
\par
Problems solvable with polynomial-time algorithms are \b tractable\b0 . Problems that cannot be solved in polynomial time are \b intractable\b0 ; calculating their solution quickly becomes infeasible. Problems that can only be solved with superpolynomial algorithms are computationally intractable, even for small \i n\i0 . Problems that are unsolvable by an algorithm are \b undecidable\b0 .\par
\par
Problems can be divided into complexity classes depending on their solutions. The \b P\b0  class consists of problems solvable in polynomial time. \b NP\b0  are all problems solvable in polynomial time only on a nondeterministic Turing machine: a variant of a Turing machine that can make guesses. NP includes P.\par
\par
Many symmetric algorithms and all public key algorithms can be cracked in nondeterministic polynomial time.\par
\par
@241\par
}
 